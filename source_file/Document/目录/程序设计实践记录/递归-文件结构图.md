
### 题目描述

会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。

对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。

给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。

### 输入

第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数b(1 <= b <= 92)

### 输出

输出有n行，每行输出对应一个输入。输出应是一个正整数，是对应于b的皇后串。

### 输入样例

#### 输入

```
2
1
92
```

#### 输出

```
15863724
84136275
```

### 实现代码

```c
#include <stdio.h>
int ans[92][8], n, b, i, j, num, hang[8];
void queen(int i){
	int j, k;
	if(i == 8){ //一组新的解产生了
		for(j = 0; j < 8; j++)  ans[num][j] = hang[j] + 1;
		num++;
		return;
	}
	for (j=0; j<8; j++){ //将当前皇后i逐一尝试放置在不同的列
        for(k=0; k<i; k++) //逐一判定i与前面的皇后是否冲突
            if( hang[k] == j || (k - i) == (hang[k] - j) || (i - k) == (hang[k] - j )) break;
		if (k == i) {  //放置i，尝试第i+1个皇后
			hang[i] = j;
			queen(i + 1);
		}
	}
}
int main( ){
	num=0;
	queen(0);
	scanf("%d", &n);
	for(i = 0; i < n; i++){
		scanf("%d", &b);
		for(j = 0; j < 8; j++)  printf("%d", ans[b - 1][j]);
		printf("\n");
	}
}
```